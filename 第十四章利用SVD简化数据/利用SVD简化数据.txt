本章内容：（奇异值分解）---图像处理
	SVD矩阵分解
	推荐引擎
	利用SVD提升推荐引擎的性能
本章将介绍SVD的概念及其能够进行数据约简的原因。然后我们将会介绍基于Python的SVD实现以及将数据映射到低维空间的过程。再接下来，我们就将学习推荐引擎的概念和他们实际运行过程。为了提高SVD的精度，我们将会把其应用到推荐系统中去，该推荐系统将会帮助人们寻找到合适的餐馆。最后我们讲述一个SVD在图像压缩中的例子。

14.1 SVD的应用
奇异值分解：
优点：简化数据，去除噪声，提高算法的结果
缺点：数据的转换可能难以理解
适用数据类型：数值型数据

利用SVD实现，我们能够用小得多的数据集来表示原始数据集。这样做，实际上是去除了噪声和冗余信息。当我们试图节省空间时，去除噪声和冗余信息就是很崇高的目标了，但是在这里我们则是从数据中抽取信息。基于这个视角，我们就可以把SVD看成是从有噪声数据中抽取相关特征。首先我们会介绍SVD是如何通过隐性语义索引应用于搜索和信息检索领域的。然后再介绍SVD在推荐系统中的应用。

14.2 推荐系统 
SVD的另一个应用就是推荐系统，简单版本的推荐系统能够计算项或者人之间的相似度。更先进的方法则先利用SVD从数据中构建一个主题空间，然后再在该空间下计算其相似度。
如果对SVD感兴趣可以阅读：Numerical liear Algebra

14.3利用Python实现SVD（numpy）

14.4基于协同过滤的推荐引擎
当然有很多方法可以实现推荐功能，这里我们只使用一种称为协同过滤的方法。协同过滤方法是通过将用户和其他用户的数据进行对比来实现推荐的。
当数据采用这种方式进行组织时，我们就可以比较用户或者物品之间的相似度了。这两种方法都会使用我们很快的介绍的相似度的概念。当知道了两个用户或两个商品之间之间的相似度。我们就可以利用已有的数据来预测未知的用户的喜好。例如，我们试图对某个用户喜欢的电影进行预测，推荐引擎会发现有一部电影该用户还没有看过，然后，它就会计算该电影和用户看过的电影之间的相似度。如果相似度高推荐算法就会认为用户喜欢这部电影。

14.4.1相似度计算。
第一种计算距离的方法是欧式距离
我们可以用“相似度 = 1/（1 + 距离）”这样的算式来计算相似度。当距离为0时，相似度为1.0，如果距离真的非常大时，相似度也就趋近于0。
第二种计算距离的方法是皮尔逊相关系数。在Numpy中，皮尔逊相关系数的计算是由函数corrcoef()进行的，后面我们很快就会用到它了。皮尔逊相关系数的取值范围为-1到1，我们通过0.5 + 0.5*corrcoef()这个函数计算，并且把其取值范围归一到0到1之间。
另外一种常用的距离计算方法就是余弦相似度。其计算的是两个向量夹角的余弦值。如果夹角为90度，则相似度为0；如果两个向量的方向相同，则相似度为1.同皮尔逊相关系数一样，余弦相似度的取值范围也在-1到1之间，因此我们也将它归一化到0到1之间。

14.4.2基于物品的相似度还是基于用户的相似度
我们计算了两个餐馆菜肴之间的距离，这称为基于物品的相似度。另一种计算用户距离的方法则称为基于用户的相似度。行与行之间比较的是基于用户的相似度，列与列之间比较的则是基于物品的相似度。

14.4.3推荐引擎的评价
通常用于推荐引擎评价的指标是称为最小均方根误差的指标，它首先计算均方误差的平均值然后取其平方根。如果评级在1星到5星。而得到的RMSE为1.0，那么意味着我们的预测值和用户给出的真实值评价相差了一个星级。

14.5 示例：餐馆菜肴推荐引擎

14.5.1推荐未尝过的菜肴
推荐系统的工作的过程是：给定一个用户，系统会为此用户返回N个最好的推荐菜。为了实现这一点，则需要我们做到：
（1）寻找用户没有评级的菜肴，即在用户-物品矩阵中的0值
（2）在用户没有评级的所有物品中，对每个物品预计一个可能的评级分数。这就是说，我们认为用户可能会对物品的打分(这就是相似度计算的初衷）
（3）对这些物品的评分从高到低进行排序，返回前N个物品。

14.5.3 构建推荐引擎面临的挑战


示例：基于SVD的图像压缩
原始图像的大小为32x32 = 1024像素，我们能否使用更少的像素来表示这张图。
我们可以使用SVD来对数据进行降维，从而实现图像的压缩。
可以看出，只需要两个奇异值就能相当精确地对图像实现重构。我们获得了几乎10倍的压缩比。
